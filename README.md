# Intro
This project explores GPU-based parallel computing for image processing, tackling its substantial computational requirements. Image processing involves applying filters to input images to produce output images. This process operates on every pixel of the image, resulting in repetitive tasks that can lead to long processing times. Parallel computing, particularly on GPUs, addresses this challenge. This project focuses on the process of blurring an image which smoothens it by reducing disparities between adjacent pixels, a process that often precedes edge detection. It centers on CUDA as the parallel programming platform and compares Gaussian Blur, Mean Blur, and Sobel Edge detection algorithms, examining both parallel and sequential implementations and their broader applicability in image processing tasks.

# Mean Blur vs Gaussian Blur
One of the simplest methods for image smoothing involves the use of a mean filter. This filter, as its name implies, seeks to replace each pixel with the average value of all neighboring pixels, including the pixel itself. While the algorithm offers simplicity and efficiency, it may encounter challenges when dealing with outliers, particularly those pixels that are significantly distant from the pixel under consideration, thus potentially skewing the calculated mean. The results of this blur can be seen in Figure 3. To better preserve edges and reduce distortions we consider Gaussian Blur a better precursor to edge detection which requires maintaining image structure and detail. Gaussian Blur works as a low-pass filter where high frequencies are essentially muted. More specifically, we can think of Gaussian Blur as a convolution process where we have a matrix (kernel) and we convolute the matrix with each pixel in our image and achieve some result. Using a larger kernel size results in a more drastic blur, thus to showcase this we have the 7x7 kernel shown in Figure 1. Gaussian blur preserves edges better than blur because the Gaussian kernel assigns lower weights to distant pixels, resulting in smoother transitions. However, Gaussian blur also requires more computational resources, especially for larger kernel sizes so the paper next examines the speed of the algorithm on a CPU versus a GPU. The results of the Gaussian Blur can be seen in Figure 4.

# Sobel Edge Detection
Edge detection can be seen as another filtration process where the “edges” on an image are emphasized which has many applications thus it is an interesting problem to explore. We will look specifically at Sobel Edge Detection which is a widely used algorithm in which the Sobel filter is used to detect edges. It works by calculating the gradient of image intensity at each pixel within the image. The result shows how abruptly or smoothly the image changes at each pixel, and therefore how likely it is that that pixel represents an edge. It also shows how that edge is likely to be oriented. We let X=S_1A and Y=S_2A where S1 and S2 are the kernels in Figure 2 (A is the 3 x 3 matrix centered around the pixel in question). Based on this we then get the magnitude which is X2+Y2 and determine if the gradient is greater than our threshold which signifies that the pixel is part of an edge or not. By taking the arctan(YX) we get the direction of the gradient or the direction of the edge. Smoothing serves as a preprocessing step to improve the quality and reliability of edge detection algorithms like Sobel Edge by reducing noise, smoothing minor intensity variations, enhancing edge localization, and enhancing structural features. The results of the Sobel Edge algorithm can be seen in Figure 5.

<img width="698" alt="Screenshot 2024-08-09 at 11 13 16 AM" src="https://github.com/user-attachments/assets/16391392-e436-46e9-9d06-9fcdc1058c93">
<img width="659" alt="Screenshot 2024-08-09 at 11 14 45 AM" src="https://github.com/user-attachments/assets/f432ceb8-f117-4758-9ac0-0174942500bf">
<img width="635" alt="Screenshot 2024-08-09 at 11 15 15 AM" src="https://github.com/user-attachments/assets/591e91ba-5fb1-47a5-9b36-c324fb96a470">
<img width="637" alt="Screenshot 2024-08-09 at 11 15 41 AM" src="https://github.com/user-attachments/assets/3d17793a-73f3-443d-a1a9-03312d00dc0f">
<img width="646" alt="Screenshot 2024-08-09 at 11 16 13 AM" src="https://github.com/user-attachments/assets/c926e8bf-5205-4c2b-a9ea-01cff331b906">

# Conclusion
The GPU demonstrates a major improvement in the processing speed of the images across all three image processing tasks compared to the CPU. This consistency in superior performance highlights the robustness of GPU capabilities as it can handle the computational demands of manipulating matrices simultaneously. GPU efficiency highlights their suitability for applications that require real-time processing, such as video editing. Although GPUs may have a higher initial cost than CPUs, the increase in processing speed often justifies the investment. 




